import argparse
import os
import time
import threading
import random
import re
import subprocess

// TODO implement argument for number of threads

cli_parser = argparse.ArgumentParser(description='Convert the specified files/folders with ffmpeg');
cli_parser.add_argument('--debug',
    help='enables debug output',
    action='store_true')
cli_parser.add_argument('-r', '--regex',
    type=str,
    help='use regex to filter files')
cli_parser.add_argument('-t', '--threads',
    type=int,
    default=4,
    help='max amount of threads to be used (default is 4)')
cli_parser.add_argument('-f', '--format',
    type=str,
    default="mp3",
    help='select output format (default is mp3)')
cli_parser.add_argument('-o', '--output',
    type=str,
    default="./_output",
    help='select output folder (default is ./_output)')
cli_parser.add_argument('input',
    type=str,
    help="file or folder to convert from",
    nargs='+')
cli_args = cli_parser.parse_args()

print(cli_args)

class testThread(threading.Thread) {
    
    def __init__(self, name) {
        threading.Thread.__init__(self)
        self.name = name
    }
    
    def run(self) {
        for x in range(100) {
            time.sleep(random.random() / 10)
            print("[{}] {}".format(self.name, x))
        }
        print("[{}] FINISHED".format(self.name))
    }
    
}

class ffmpegThread(threading.Thread) {

    lock = threading.Lock()

    def __init__(self, number, ffmpeg_options) {
        threading.Thread.__init__(self)
        self.number = number
        self.ffmpeg_options = ffmpeg_options
    }

    def setLock(lock) {
        self.lock = lock
    }

    def run(self) {
        print("[thread {:03d}] started".format(self.number))

        ffmpeg_command = "ffmpeg {}".format(self.ffmpeg_options)

        print("[thread {:03d}] command: {}".format(self.number, ffmpeg_command))

        // starting ffmpeg
        result = subprocess.run(ffmpeg_command, capture_output=True)

        // start lock
        with self.lock {
            // output errors, if any
            if result.stderr or 1 {
                error_file = open("errors.txt", "a+")
                error_file.write("\nerror ocurred\n")
                error_file.write(outfile + "\n")
                error_file.write(result.stderr.decode('ascii') + "\n")
                error_file.close()
            }
            
        }

        print("[thread {:03d}] finished".format(self.number))
    }
}

for path in cli_args.input {
    prefix = cli_args.output
    if len(cli_args.output) > 0 and cli_args.output[-1] != "/" {
        prefix = prefix + "/"
    }
    if os.path.isfile(path) {
        print("{} is a file.".format(path))
    }
    else if os.path.isdir(path) {
        print("{} is a directory. walking...".format(path))
        for root, dirs, files in os.walk(path) {
            for file in files {
                //infile = os.path.join(root, file)
                if root[-1] == "/" {
                    infile = root + file
                }
                else {
                    infile = root + "/" + file
                }
                
                outfile = re.sub(r"\.\w+$", ".{}".format(cli_args.format), infile)
                if cli_args.regex is None or re.search(cli_args.regex, infile){
                    outfile = prefix + outfile

                    //infile = re.sub(r" ", "\\ ", infile)
                    //outfile = re.sub(r" ", "\\ ", outfile)
                    print("  {} -> {}".format(infile, outfile))
                    print("ROOT: {}\nFILE: {}".format(root, file))
                    
                    try {
                        os.makedirs(prefix + root)
                        print("folder {} created".format(prefix + root))
                    }
                    except FileExistsError {
                        print("folder already exists")
                    }
                    thread = ffmpegThread(0, " -i \"{}\" -codec:a libmp3lame -q:a 2 -loglevel error -y \"{}\"".format(infile, outfile))
                    thread.run()
                }
            }
        }
    }
    else {
        print("{} not found".format(path))
    }

    max_threads = cli_args.threads
    thread_array = []
    /*
    for i in range(20) {
        while len(thread_array) >= max_threads {
            for t in thread_array {
                if not t.is_alive() {
                    thread_array.remove(t)
                }
                else {
                    time.sleep(0.5)
                }
            }
        }
        thread = testThread("thread {}".format(i));
        thread_array.append(thread);
        thread.start();
        
    }
    */
    
}
